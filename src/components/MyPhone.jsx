/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.10 3d-phone-update.glb 
*/

import React, { useEffect, useMemo, useRef, useState } from "react";
import { Html, useGLTF } from "@react-three/drei";
import * as THREE from "three";
import { scroller } from "react-scroll";
import { notifyInfo } from "../utils/notifications";

import model from "/3d-phone-update.glb?url"

export function MyPhone(props) {
  const { nodes, materials } = useGLTF(model);

  // Phone state
  const [isOn, turnOn] = useState(false);
  const [firstTouch, setFirstTouch] = useState(false);
  // selection section state
  const [sectionSelected, setSectionSelected] = useState("");

  // ICONS GROUP REF
  const groupIconsRef = useRef();
  const screenRef = useRef();

  // REF AND HOVER EVENTS

  let iconWorkRef = useRef();
  let iconHomeRef = useRef();
  let iconSkillsRef = useRef();
  let iconEducationRef = useRef();
  let iconContactRef = useRef();
  let iconBackRef = useRef();

  // cambia la escala del mesh dependiendo del estado del cursor
  const handleMouseEnter = (ref) => {
    if (ref.current) {
      ref.current.scale.set(0.25, 0.25, 0.25);
    }
  };

  const handleMouseLeave = (ref) => {
    if (ref.current) {
      ref.current.scale.set(0.2, 0.2, 0.2);
    }
  };

  // TEXTURES!!
  const textureLoader = new THREE.TextureLoader();
  // background state

  // pantalla

  const wallpaperMaterial = useMemo(
    () =>
      new THREE.MeshStandardMaterial({
        map: textureLoader.load("./images/homeWallpaper.jpg"),
        metalness: 1,
        roughness: 0.01,
        side: THREE.DoubleSide,
      }),
    []
  );

  /* ICONOS */

  // useMemo is a React hook used for memoizing the result of a function or a computation.

  const introductionIconMaterial = useMemo(
    () =>
      new THREE.MeshStandardMaterial({
        map: textureLoader.load("./images/home.png"),
        alphaTest: 0.5,
        transparent: true,
        side: THREE.DoubleSide,
      }),
    []
  );

  const workIconMaterial = useMemo(
    () =>
      new THREE.MeshStandardMaterial({
        map: textureLoader.load("./images/files.png"),
        alphaTest: 0.5,
        transparent: true,
        side: THREE.DoubleSide,
      }),
    []
  );

  const skillsIconMaterial = useMemo(
    () =>
      new THREE.MeshStandardMaterial({
        map: textureLoader.load("./images/code.png"),
        alphaTest: 0.5,
        transparent: true,
        side: THREE.DoubleSide,
      }),
    []
  );

  const educationIconMaterial = useMemo(
    () =>
      new THREE.MeshStandardMaterial({
        map: textureLoader.load("./images/notebook.png"),
        alphaTest: 0.5,
        transparent: true,
        side: THREE.DoubleSide,
      }),
    []
  );

  const contactIconMaterial = useMemo(
    () =>
      new THREE.MeshStandardMaterial({
        map: textureLoader.load("./images/message.png"),
        alphaTest: 0.5,
        transparent: true,
        side: THREE.DoubleSide,
      }),
    []
  );

  const goBackIconMaterial = new THREE.MeshStandardMaterial({
    map: textureLoader.load("./images/goBack.png"),
    alphaTest: 0.5,
    transparent: true,
    side: THREE.DoubleSide,
  });

  // HOUR MATERIAL
  const createHourMaterial = () => {
    // creando un canvas
    const canvas = document.createElement("canvas");
    const context = canvas.getContext("2d");
    canvas.width = 260;
    canvas.height = 80;

    // obtenemos y damos formato a la hora
    const date = new Date();
    const hour = `${date.getHours()} : ${
      date.getMinutes() < 10 ? "0" + date.getMinutes() : date.getMinutes()
    }`;

    // damos estilo al text

    context.font = "30px Arial";
    context.fillStyle = "white";
    context.textAlign = "center";
    context.fillText(hour, canvas.width / 2, canvas.height / 2);

    const texture = new THREE.CanvasTexture(canvas);

    return texture;
  };

  const hourTexture = new THREE.MeshStandardMaterial({
    map: createHourMaterial(),
    metalness: 1,
    roughness: 0.5,
    side: THREE.DoubleSide,
    transparent: true,
  });

  // CLICK APP EVENTS !!!
  // cambia el estado del section seleccionado y hace scroll al section seleccionado
  // section: un string que debe ser igual al id de los <section id='section'> en Segments.jsx
  const handleClickApp = (section) => {
    // setBg(bgImages[section])
    props.appClicked(section);

    scroller.scrollTo(section, {
      duration: 1500,
      delay: 100,
      smooth: "easeInOutQuart",
      offSet: 0,
    });
  };

  return (
    <group {...props} scale={3.5} dispose={null} rotation={[0, -1.75, 0]}>
      {!isOn && (
        <mesh
          geometry={nodes.HourPlane.geometry}
          material={materials.Screen}
          position={[0, 3.199, 0.124]}
          rotation={[Math.PI / 2, Math.PI, Math.PI]}
          scale={[0.705, 0.385, 0.385]}
        >
          <primitive object={hourTexture} attach="material" />
        </mesh>
      )}

      <group
        position={[0.01, 2.17, 0.004]}
        rotation={[Math.PI / 2, Math.PI / 2, 0]}
        scale={32}
      >
        <mesh
          geometry={nodes.Cube001.geometry}
          material={materials.bodyMaterial}
        />
        <mesh
          geometry={nodes.Cube001_1.geometry}
          material={materials.blackMaterial}
        />
      </group>

      {/* POWER BUTTON */}

      <mesh
        geometry={nodes.PowerButton.geometry}
        material={materials.buttonsMaterial}
        position={[1.024, 2.598, 0.004]}
        rotation={[Math.PI / 2, 0, 0]}
        scale={[0.013, 0.052, 0.117]}
        onClick={() => {
          turnOn(!isOn);
          if (!firstTouch)
            notifyInfo(
              "Navega por la página dando click en las apps."
            );
        }}
      />

      {!firstTouch && (
        <Html className="w-10 select-none" position={[1.024, 2.598, 0.1]}>
          <img
            className="w-5 animate-ping duration-500"
            onClick={() => {
              setFirstTouch(true);
              turnOn(!isOn);
              notifyInfo(
                "Navega por la página dando click en las apps."
              );
            }}
            src="./images/hold.png"
          />
        </Html>
      )}

      <mesh
        geometry={nodes.VolumeButton.geometry}
        material={materials.buttonsMaterial}
        position={[1.016, 2.99, 0.004]}
        rotation={[Math.PI / 2, 0, 0]}
        scale={[0.038, 0.058, 0.098]}
      />
      <mesh
        geometry={nodes.LoadingPort.geometry}
        material={materials.blackMaterial}
        position={[0.01, 0.132, 0.004]}
        rotation={[Math.PI / 2, 0, 0]}
        scale={[0.099, 0.007, 0.04]}
      />

      {/* SCREEN MESH */}
      <mesh
        geometry={nodes.Screen.geometry}
        material={materials.Screen}
        position={[0.01, 2.17, 0.004]}
        rotation={[Math.PI / 2, Math.PI / 2, 0]}
        scale={32}
      >
        {isOn && <primitive object={wallpaperMaterial} attach="material" />}
      </mesh>

      {/* ICONS APPS */}

      {isOn && (
        <group position={[0.05, 0, 0]}>
          <mesh
            name="introduction"
            ref={iconHomeRef}
            onClick={() => handleClickApp("introduction")}
            geometry={nodes.HourPlane.geometry}
            material={materials.Screen}
            position={[-0.05, 0.4, 0.124]}
            rotation={[Math.PI / 2, Math.PI, Math.PI]}
            scale={[0.1, 0.1, 0.1]}
          >
            <primitive object={introductionIconMaterial} attach="material" />
          </mesh>

          <mesh
            name="skills"
            ref={iconSkillsRef}
            onPointerOver={() => handleMouseEnter(iconSkillsRef)}
            onPointerLeave={() => handleMouseLeave(iconSkillsRef)}
            onClick={() => handleClickApp("knowledge")}
            geometry={nodes.HourPlane.geometry}
            material={materials.Screen}
            position={[-0.65, 0.8, 0.124]}
            rotation={[Math.PI / 2, Math.PI, Math.PI]}
            scale={[0.2, 0.2, 0.2]}
          >
            <primitive object={skillsIconMaterial} attach="material" />
          </mesh>

          <mesh
            name="work"
            ref={iconWorkRef}
            onPointerOver={() => handleMouseEnter(iconWorkRef)}
            onPointerLeave={() => handleMouseLeave(iconWorkRef)}
            onClick={() => handleClickApp("work")}
            geometry={nodes.HourPlane.geometry}
            material={materials.Screen}
            position={[-0.25, 0.8, 0.124]}
            rotation={[Math.PI / 2, Math.PI, Math.PI]}
            scale={[0.2, 0.2, 0.2]}
          >
            <primitive object={workIconMaterial} attach="material" />
          </mesh>

          <mesh
            name="education"
            ref={iconEducationRef}
            onPointerOver={() => handleMouseEnter(iconEducationRef)}
            onPointerLeave={() => handleMouseLeave(iconEducationRef)}
            onClick={() => handleClickApp("education")}
            geometry={nodes.HourPlane.geometry}
            material={materials.Screen}
            position={[0.15, 0.8, 0.124]}
            rotation={[Math.PI / 2, Math.PI, Math.PI]}
            scale={[0.2, 0.2, 0.2]}
          >
            <primitive object={educationIconMaterial} attach="material" />
          </mesh>

          <mesh
            name="contact"
            ref={iconContactRef}
            onPointerOver={() => handleMouseEnter(iconContactRef)}
            onPointerLeave={() => handleMouseLeave(iconContactRef)}
            onClick={() => handleClickApp("contact")}
            geometry={nodes.HourPlane.geometry}
            material={materials.Screen}
            position={[0.55, 0.8, 0.124]}
            rotation={[Math.PI / 2, Math.PI, Math.PI]}
            scale={[0.2, 0.2, 0.2]}
          >
            <primitive object={contactIconMaterial} attach="material" />
          </mesh>
        </group>
      )}

      {/* {(isOn && bg !== bgImages.introduction) && (
        <mesh
        name="back"
        ref={iconHomeRef}
        onClick={() => setBg(bgImages.introduction)}
        geometry={nodes.HourPlane.geometry}
        material={materials.Screen}
        position={[-0.7, 3.9, 0.124]}
        rotation={[Math.PI / 2, Math.PI, Math.PI]}
        scale={[0.06, 0.06, 0.06]}
      >
        <primitive object={goBackIconMaterial} attach="material" />
      </mesh>
      )} */}

      <mesh
        geometry={nodes.Frame.geometry}
        material={materials.cameraMaterial}
        position={[0.01, 2.17, 0.004]}
        rotation={[Math.PI / 2, Math.PI / 2, 0]}
        scale={32}
      />
      <group
        position={[0.65, 3.881, -0.123]}
        rotation={[Math.PI / 2, 0, 0]}
        scale={[0.166, 0.231, 0.166]}
      >
        <mesh
          geometry={nodes.Circle.geometry}
          material={materials.blackMaterial}
        />
        <mesh
          geometry={nodes.Circle_1.geometry}
          material={materials.GlassTransparentMaterial}
        />
        <mesh
          geometry={nodes.Circle_2.geometry}
          material={materials.lensMaterial}
        />
      </group>
      <group
        position={[0.65, 3.497, -0.123]}
        rotation={[Math.PI / 2, 0, 0]}
        scale={[0.166, 0.231, 0.166]}
      >
        <mesh
          geometry={nodes.Circle003.geometry}
          material={materials["blackMaterial.001"]}
        />
        <mesh
          geometry={nodes.Circle003_1.geometry}
          material={materials["GlassTransparentMaterial.001"]}
        />
        <mesh
          geometry={nodes.Circle003_2.geometry}
          material={materials["lensMaterial.001"]}
        />
      </group>
      <mesh
        geometry={nodes.Cube.geometry}
        material={materials.cameraMaterial}
        position={[0.499, 3.699, 0.121]}
        rotation={[Math.PI / 2, 0, 0]}
        scale={[0.434, 0.189, 0.434]}
      />
      <group
        position={[0.298, 3.683, -0.123]}
        rotation={[Math.PI / 2, 0, 0]}
        scale={0.075}
      >
        <mesh
          geometry={nodes.Circle002.geometry}
          material={materials.GlassTransparentMaterial}
        />
        <mesh
          geometry={nodes.Circle002_1.geometry}
          material={materials.whiteMaterial}
        />
      </group>
      <mesh
        geometry={nodes.Sphere.geometry}
        material={materials.lensMaterial}
        position={[0.01, 4.109, 0.105]}
        rotation={[Math.PI / 2, 0, 0]}
        scale={[0.016, 0.004, 0.016]}
      />
    </group>
  );
}

useGLTF.preload(model);
